<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favcion.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="大型 java 从零开始踩坑现场">
<meta property="og:type" content="article">
<meta property="og:title" content="java 学习全程记录">
<meta property="og:url" content="https://c-or.github.io/2019/java-learning.html">
<meta property="og:site_name" content="小2C">
<meta property="og:description" content="大型 java 从零开始踩坑现场">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-04-26T06:56:45.304Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java 学习全程记录">
<meta name="twitter:description" content="大型 java 从零开始踩坑现场">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>

<meta name="baidu-site-verification" content="vVivsCLiUP">
<meta name="google-site-verification" content="T76U9GSczlu2sdzC2WTMgMOuIRie7ewmPbnoPMgRh4Y">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-133175781-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-133175781-1');
</script>




  <link rel="canonical" href="https://c-or.github.io/2019/java-learning.html">





  <title>java 学习全程记录 | 小2C</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小2C</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://c-or.github.io/2019/java-learning.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="or">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小2C">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java 学习全程记录</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-28T11:03:43+08:00">
                2019-02-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/java-learning.html" class="leancloud_visitors" data-flag-title="java 学习全程记录">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  9.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  37
                </span>
              
            </div>
          

          


        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>大型 java 从零开始踩坑现场</p>
<a id="more"></a>
<p><a href="https://blog.csdn.net/yxpandjay/article/details/80209429" target="_blank" rel="noopener">java 中 static 和 public 的用法</a></p>
<h2 id="java-中关于类的操作"><a href="#java-中关于类的操作" class="headerlink" title="java 中关于类的操作"></a>java 中关于类的操作</h2><h3 id="类的写法"><a href="#类的写法" class="headerlink" title="类的写法"></a>类的写法</h3><p>类的写法格式如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我正在学习！"</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>貌似在类的非方法语段只能进行变量的定义操作，其他操作都是不允许的，如果想要进行其他操作则需要使用 static 语段。比说说要打印一段话则需要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static&#123;</span><br><span class="line">    System.out.println(&quot;....&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="java-中类的实例化"><a href="#java-中类的实例化" class="headerlink" title="java 中类的实例化"></a>java 中类的实例化</h3><p>以上面创建的类为例说明 java 中实例化操作，java 中标准化的实例语句为 <code>Student stu = new Student();</code> 其中 <code>Student stu</code> 的意思是，在内存中分配一个名字叫做 stu 的变量，这个变量是 Student 类型的。后半部分 <code>new Student()</code> ；这就是利用 new 关键字加上构造方法(所谓构造方法就是在类名后加上一个括号，如Student() ) 来创建一个实例，比如示例代码中创建的就是一个 Student 类的实例。当使用 new 关键字创建一个新的实例后，new 关键字会将新创建的实例在内存中的地址返回，之后 stu 将会接受这个地址，所以 stu 就是Student 类实例的一个引用，而不是实例本身，真正的实例是 new 出来的那个对象。</p>
<h3 id="java-中构造方法及其作用"><a href="#java-中构造方法及其作用" class="headerlink" title="java 中构造方法及其作用"></a>java 中构造方法及其作用</h3><p>构造方法就是对类进行初始化，个人理解它是与 python 中的 <code>__init()_</code> 相似的方法，都是对类中的变量进行初始化，通过初始化将值赋给类中的变量，这样在以后调用类中的数据时可以有效区分类内部的变量和类外部的变量，防止出错。</p>
<p>java 中构造方法的特点：</p>
<p>1.构造方法的名称需要与类的名称一致</p>
<p>2.当类中没有需要初始化的参数时会直接调用自动生成的无参数构造方法，也就是类名加括号；当类中存在需要初始化的参数时，将不会自动生成构造方法，这时就需要自己编写构造方法，根据规范，在自定义含参构造器的同时还需要定义一个不含参的构造器。构造方法内部需要将传入的参数赋给类中的变量。代码示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person //人类&#123;</span><br><span class="line">public Person(String n,int a) //构造方法</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> name = n; age = a;</span><br><span class="line">&#125;</span><br><span class="line"> private string name;</span><br><span class="line"> private int age;</span><br><span class="line">&#125;</span><br><span class="line">static void main(String[] args)&#123;</span><br><span class="line">Person p = new Person(&quot;张三&quot;,14);//这就是作用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法也存在重载，这和以前普通方法的重载是一样的</p>
<h3 id="this-的使用场景"><a href="#this-的使用场景" class="headerlink" title="this 的使用场景"></a>this 的使用场景</h3><p>1.发生二义性的情况下通过 this 区分局部变量和成员变量，如类的构造方法中传入的参数名和成员变量名相同这是需要使用 this 进行区分</p>
<p>2.在构造方法重载时使用。如：构造方法1对 a 、b 两个变量进行赋值，而构造方法2对 a、b、c三个成员变量进行赋值，这时可以通过语句 <code>this(a,b)</code> 调用另一个构造方法，然后再单独对成员变量  c 进行赋值。需要注意的是 this 语句必须写在构造方法的第一行。</p>
<p>2.不能用于 static 语句中。</p>
<h3 id="static-用法"><a href="#static-用法" class="headerlink" title="static 用法"></a>static 用法</h3><p>使用 static 声明的变量和方法可以全局使用，static 代码块会跟随类一起加载，也就是说他会在所有其他操作之前进行，毕竟类初始化加载之后才能对类进行操作，同理，不能在静态方法中调用非静态变量。静态方法可以调用静态方法，究其缘由就是因为静态方法会随着类一起加载，而普通方法则要在类实例化后才能加载，所以静态方法无法找到还没有生成的普通方法也就没法调用(我是这么理解的也不知道对不对)</p>
<h3 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h3><p>java 包的导入使用 import 关键词，当导入的多个包里存在相同的名称时将会优先使用描述更加详细的那一项。例如 <code>import java.util.Date</code> 和 <code>import java.sql.*</code> 中都含有Date方法，这是就会使用 util 中的 Date ，因为它描述的更加详细。</p>
<h4 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h4><p>使用 <code>import static</code> 表示导入类下面的静态属性，例如导入圆周率 PI ，可以使用 <code>import static java.lang.Math.PI</code> 或 <code>import static java.lang.Math.*</code></p>
<h2 id="垃圾回收算法与机制"><a href="#垃圾回收算法与机制" class="headerlink" title="垃圾回收算法与机制"></a>垃圾回收算法与机制</h2><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><p>垃圾回收算法分为计数法和根搜索算法。</p>
<p>计数法存在相互调用的问题故不太稳定。根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点 GC ROOT 开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</p>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p> java中不同对象的生命周期是不一样的，不同周期对象课采用不同垃圾回收算法，以提高效率，根据对象活跃程度分为年轻代、年老代、持久代。JVM 堆区划分为 Eden、Survivor、Tenured/Old 区。</p>
<p>年轻代<br>        所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分为 Eden 区和两个 Survivor (一般为两个，也可多个)。</p>
<p>年老代<br>        在年轻代中经历N次垃圾回收后，仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p>
<p>持久代<br>        存放静态文件，如 java 类、方法等，对垃圾回收没有显著影响</p>
<p>GC:  Garbage Collection 垃圾回收<br>Minor GC<br>        用于清理年轻代，Eden 满了，就触发 Minor GC ，清理无用对象，把有用对象放到Survivor1或 Survivor2 中。</p>
<p>Major GC<br>        用于清理老年代。</p>
<p>Full GC<br>        清理年轻代、老年代区域，成本高，对系统性能产生影响</p>
<p>清理过程 </p>
<ol>
<li><p>创建新对象，大多数放在Eden区</p>
</li>
<li><p>Eden满了（或达到一定比例），触发Minor GC,   把有用的复制到Survivor1, 同时清空Eden区。</p>
</li>
<li><p>Eden区再次满了，出发Minor GC, 把Eden和Survivor1中有用的，复制到Survivor2, 同时清空Eden，Survivor1。</p>
</li>
<li><p>Eden区第三次满了，出发Minor GC, 把Eden和Survivor2中有用的，复制到Survivor1, 同时清空Eden，Survivor2。</p>
<p>形成循环，Survoivor1和Survivor中来回清空、复制，过程中有一个Survivor处于空的状态用于下次复制的。</p>
</li>
<li><p>重复多次（默认15），没有被Survivor清理的对象，复制到Old（Tenuerd）区.</p>
</li>
<li><p>当Old达到一定比例，触发Major GC，清理老年代。        </p>
</li>
<li><p>当Old满了，触发Full GC。注意，Full GC清理代价大，系统资源消耗高。</p>
</li>
</ol>
<p>注： </p>
<ol>
<li><p>程序员可以像JVM提出垃圾回收请求，但是实际是否回收由JVM决定，程序员只提出清理请求建议，不能直接清理。</p>
</li>
<li><p>Full GC清理代价大，系统资源消耗高，很多性能优化是针对Full GC做优化。</p>
</li>
</ol>
<p>参考资料：<a href="https://blog.csdn.net/xmj15715216140/article/details/80664630" target="_blank" rel="noopener">https://blog.csdn.net/xmj15715216140/article/details/80664630</a></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承的概念和 python 的一样，现在说一下 java 继承的用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">     String name;</span><br><span class="line">     <span class="keyword">int</span> height;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rest</span><span class="params">()</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"我正在休息"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">     String major;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"一周学七天，一学期学一周"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> height,String major)</span></span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.name = name;</span><br><span class="line">     <span class="keyword">this</span>.height = height;</span><br><span class="line">     <span class="keyword">this</span>.major = major;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="string">"张三"</span>,<span class="number">178</span>,<span class="string">"****"</span>);</span><br><span class="line"></span><br><span class="line">        student.rest();</span><br><span class="line">        student.study();</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如上所示直接使用 extends 进行继承就行了</p>
<p>子类继承父类可以得到父类的全部属性和方法（除了父类的构造方法），但不见得可以直接访问，比如父类的私有属性和方法。如果定义一个类时，没有调用extends，则它的父类是 java.lang.Object。</p>
<p>在编写构造函数的时候需要注意的是构造函数本身并没有返回值，所以在编写构造函数时不能使用 void 关键字，否则会报错，提示构造函数未被创建！！</p>
<p>可以使用 instanceof 判断两个类之间的继承关系，比如说 <code>Student instanceof Person</code> 返回的就是 True 因为 Student 是Person 的子类。</p>
<h3 id="继承方法的重写"><a href="#继承方法的重写" class="headerlink" title="继承方法的重写"></a>继承方法的重写</h3><p>若要改写父类中定义的方法，则需要对方法进行重写，重写的方法是在子类中重新定义一个和父类中方法名一致的方法然后对方法进行自己想要的改写。代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOverride</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Hourse h = <span class="keyword">new</span> Hourse();</span><br><span class="line">        h.run();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"跑....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"停！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hourse</span> <span class="keyword">extends</span> <span class="title">Vehicle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"四蹄翻飞，嘚嘚嘚..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是重写方法的返回类型必须小于父类的返回类型，比如说父类返回的是继承于 Object 的，如果重写的返回类型直接就是 Object 类，这样就会出错。</p>
<p>可以基于此对 Object 类的一些方法进行重写以满足自己的需要，例如对 equal 类的重写。Object 的 equal 方法是判断两个类的内容是否一致，但如果我们仅仅只需要类中的其中一个属性来进行判断，这时就可以进行重写。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Object obj;</span><br><span class="line">        String str;</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="string">"张三"</span>,<span class="number">123456</span>,<span class="number">12345</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="string">"李四"</span>,<span class="number">123456</span>,<span class="number">54321</span>);</span><br><span class="line">        System.out.println(u1.equals(u2));</span><br><span class="line">        System.out.println(u1 == u2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> pwd;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name,<span class="keyword">int</span> id,<span class="keyword">int</span> pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;<span class="comment">//对Object的equal方法进行重写，通过ID判断是否相等</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        User other = (User) obj;</span><br><span class="line">        <span class="keyword">if</span> (id != other.id)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个打印语句，第一个打印 True， 第二个打印 False。这是因为 u1 和 u2 是两个不同的对象，故不相等，但两个对象的 ID 是相等的，故改写后的 equal 方法返回 True。equal 方法的改写可以通过 eclipse 右键菜单的 source 选项内功能直接生成。</p>
<h3 id="super-的用法"><a href="#super-的用法" class="headerlink" title="super 的用法"></a>super 的用法</h3><p>super 是当父类的方法被重写之后，在子类中调用父类方法的关键字。如父类中一个叫做 f() 的方法，在子类中被重写了，如果想要在子类中重新调用重写之前的方法就需要使用 super.f() 。</p>
<p>此外，super 还用在构造方法之中。每个构造方法的第一句不论写不写都是 super() ，这也就导致了当你 new 一个新对象时，肯定会先运行对应类的父类构造器，层层向上。当使用 <code>super()</code> 传递参数时，只能传递父类构造器中声明的参数，其他的可以使用 <code>super().value = ****</code> 形式进行值传递</p>
<h4 id="类的向上向下转型"><a href="#类的向上向下转型" class="headerlink" title="类的向上向下转型"></a>类的向上向下转型</h4><p>当用父类名称声明子类实例时，该实例只能调用子类和父类共有的方法，若有方法在子类中被重写，则调用的是重写后的方法。向下转型使用强制转型方法，转型后可以使用子类独有的方法。例如： Animal 是 Dog 的父类，那么 <code>Animal dog = new Dog()</code> 声明的的 dog 只能使用 Dog 类和 Animal 类共有的方法，如果使用语句 <code>dog = (Dog)dog</code> 将 dog 向下转型为 Dog 类实例，则 dog 可以使用 Dog 类独有的方法。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>tips：面向对象的三大特征：继承，封装和多态</p>
<p>高内聚：类的内部数据操作细节自己完成，不允许外部干涉</p>
<p>低耦合：仅暴露少量的方法给外部使用，尽量方便外部调用</p>
<h4 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h4><p>private：表示私有，只能自己类访问，子类无法使用父类的私有属性和方法</p>
<p>default：表示没有修饰符修饰，只有同一个包的类能访问</p>
<p>protected：表示可以被同一个包的类以及其他包中的子类访问</p>
<p>public：表示可以被该项目的所有包中的所有类访问</p>
<p>当编写一个类时，应该把其中的所有属性设置成私有，然后为每个属性设置属性为 public 的 set 和 get 方法，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>set get 方法可利用 eclipse 右键菜单内相应选项直接生成。类里面的普通方法一般使用 public 即可。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态指同一个方法调用，由于对象不同可能会有不同的行为。现实生活中，同一个方法，具体实现会完全不同。</p>
<p>多态的要点：</p>
<p>1.多态是方法的多态，不是属性的多态（多态与属性无关）</p>
<p>2.多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。</p>
<p>3.父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了</p>
<p>比如说有 animal ， dog ，cat 三个类，其中 dog 和 cat 是 animal 的子类，当定义一个方法，其中的形参是 animal a ，这时传入 dog 类和 cat 类都行，如果不用父类来定义形参，那么就得根据可能出现调用情况分别编写几个形参不同的方法，这就很繁琐</p>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final 关键字的作用：</p>
<p>1.修饰变量：被他修饰的变量不可改变，一旦赋了初值，就不能被重新赋值</p>
<p>2.修饰方法：该方法不可被子类重写，但是可以被重载</p>
<p>3.修饰类：修饰的类不能被继承</p>
<h3 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h3><p>用于读取数组元素的值，不能修改元素的值</p>
<p>其用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)</span><br><span class="line">            a[i] = i*<span class="number">100</span>;</span><br><span class="line">        <span class="comment">//foreach循环遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m:a)&#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>1.抽象类以及抽象方法使用 abstract 关键词修饰</p>
<p>2.抽象方法指的是只定义了名称但没有内容的方法</p>
<p>3.有抽象方法的类只能定义成抽象类</p>
<p>4.抽象类不能实例化，既不能用 new 来实例化抽象类</p>
<p>5.抽象类可以包含属性、方法、构造方法。但是构造方法不能用来 new 实例，只能用来被子类调用</p>
<p>6.抽象类只能用来继承</p>
<p>7.抽象方法必须被子类实现</p>
<p>抽象方法的意义在于：将方法的设计和方法的实现分离了</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>1.接口就是比“抽象类” 还 “抽象” 的 “抽象类”，可以更加规范的对子类进行约束。全面专业地实现了：规范和具体实现的分离。</p>
<p>2.借口就是规范，定义的是一组规则，体现了现实世界中 “如果你是……</p>
<p>则必须能……“ 的思想</p>
<p>3.接口的本质是契约，就像我们人间的法律一样。制定好后大家都遵守</p>
<p>4.项目的具体需求是多变的，我们必须以不变应万变才能从容开发，此处的“不变”就是“规范”。因此，我们开发项目往往都是面向接口编程！</p>
<p>接口的写法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">myInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name = <span class="string">"阿Q"</span>;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> speed)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>定义接口的关键字是 interface ，接口内定义的变量会自动被转化为常量，也就是说不管你写不写，定义变量的语句前面都会自动加上 <code>public static final</code> 语句，对于方法声明语句则会自动在前面加上 <code>public abstract</code> 语句</p>
<p>下面再补充一下实现接口的类的写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">myInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是"</span>+myInterface.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.子类通过 implements 来实现接口中的规范</p>
<p>2.接口不能创建实例，但是可用于声明引用型变量</p>
<p>3.一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的</p>
<p>4.一个子类可以同时实现多个接口，不同接口之间使用<code>,</code>隔开</p>
<p>5.接口可以多继承</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调函数( callback )又称钩子函数( hook )，回调函数的实现是通过参数传递一个类，然后调用这个类的方法，也就是说传入的类不同，所执行的操作也就会不同，为了保证操作的稳定可用，此处可结合抽象类或接口，在形参上将实参所包含的方法进行限制。实际的例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(operation w)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"日常操作1"</span>);</span><br><span class="line">        System.out.println(<span class="string">"日常操作2"</span>);</span><br><span class="line">        w.work();</span><br><span class="line">        System.out.println(<span class="string">"日常操作3"</span>);</span><br><span class="line">        System.out.println(<span class="string">"日常操作4"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> operation1());          <span class="comment">//实例化operation1并向test方法传递</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">operation</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">operation1</span> <span class="keyword">extends</span> <span class="title">operation</span></span>&#123;        <span class="comment">//实现抽象类operation</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在工作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>一般情况，我们把类定义成独立的单元。有些情况下，我们把一个类放在另一个类的内部定义，称为<strong>内部类</strong></p>
<h4 id="内部类的作用"><a href="#内部类的作用" class="headerlink" title="内部类的作用"></a>内部类的作用</h4><p>1.内部类提供了更好的封装。只能让外部类直接访问，不允许同一个包中的其他类<strong>直接访问</strong></p>
<p>2.内部类可以<strong>直接访问</strong>外部类的私有属性，内部类被当成其外部类的乘员。但外部类不能访问内部类的内部属性</p>
<h4 id="内部类的使用场合"><a href="#内部类的使用场合" class="headerlink" title="内部类的使用场合"></a>内部类的使用场合</h4><p>由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性。所以，<strong>通常内部类在只为所在外部类提供服务的情况下优先使用</strong></p>
<h4 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h4><p>1.非静态内部类必须寄存在一个外部类对象里。因此，如果有一个非静态内部类对象。那么一定存在对应的外部类对象。<strong>非静态内部类对象单独属于外部类的某个对象</strong></p>
<p>2.非静态内部类可以使用外部类的成员，但是外部类不能直接访问非静态内部类成员</p>
<p>3.非静态内部类不能有静态方法、静态属性、静态初始化块</p>
<p>4.<strong>静态成员不能访问非静态成员:</strong> 外部类的静态方法、静态代码块不能访问非静态内部块，包括不能使用非静态内部类定义变量、创建实例。</p>
<p>5.<strong>成员变量访问要点：</strong></p>
<pre><code>1)内部类里的局部变量：变量名

(2)内部类属性：this.变量名

(3)外部类属性：外部类名.this。变量名
</code></pre><p>6.内部类的访问：</p>
<pre><code> (1)外部类中定义内部类：new innerClass()

(2)外部以外的地方使用非静态内部类：

先需要 new 外部类，再通过外部类实例.new 内部类 的形式创建内部类实例
</code></pre><p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Face f = <span class="keyword">new</span> Face();</span><br><span class="line">        Face.Nose n = f.new Nose();</span><br><span class="line">        n.breath();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Face</span></span>&#123;</span><br><span class="line">    String type=<span class="string">"瓜子脸"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nose</span></span>&#123;</span><br><span class="line">        String type = <span class="string">"酒糟鼻"</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(type);</span><br><span class="line">            System.out.println(Face.<span class="keyword">this</span>.type);</span><br><span class="line">            System.out.println(<span class="string">"呼吸！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当内部类和外部类出现重名变量时，直接使用变量名和 <code>this.变量名</code> 都是引用内部类变量，若要引用外部类变量则需要使用 <code>外部类.this.变量名</code></p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>1.定义方式：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ststic class ClassName&#123;</span><br><span class="line">    //类体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.使用要点</p>
<p>(1)<strong>当一个静态内部类存在，并不一定存在对应的外部类对象</strong>。因此，静态内部类的实例方法并不能直接访问外部类的实例方法</p>
<p>(2)<strong>静态内部类看做外部类的一个静态成员</strong> 。因此，外部类的方法可以通过：<code>静态内部类.名字</code> 访问静态内部类的静态成员。通过 new 静态内部类() 访问静态内部类的实例</p>
<p>(3)在外部类的外面创建静态内部类：</p>
<p><code>外部类.内部静态类 变量名 = new 外部类.内部静态类()</code></p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Face f = <span class="keyword">new</span> Face();</span><br><span class="line">        Face.Nose n = f.new Nose();</span><br><span class="line">        n.breath();</span><br><span class="line">        Face.Ear e = <span class="keyword">new</span> Face.Ear();</span><br><span class="line">        e.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Face</span></span>&#123;</span><br><span class="line">    String type=<span class="string">"瓜子脸"</span>;</span><br><span class="line">    <span class="keyword">static</span> String color = <span class="string">"红润"</span>;</span><br><span class="line">    String shape = <span class="string">"圆"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nose</span></span>&#123;</span><br><span class="line">        String type = <span class="string">"酒糟鼻"</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(type);</span><br><span class="line">            System.out.println(Face.<span class="keyword">this</span>.type);</span><br><span class="line">            System.out.println(<span class="string">"呼吸！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ear</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(color);<span class="comment">//静态类能直接访问外部类的静态成员</span></span><br><span class="line">            <span class="comment">//System.out.println(shape);静态类并不能直接访问外部类的非静态成员</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"我在听！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结合源码分析-String-类用法"><a href="#结合源码分析-String-类用法" class="headerlink" title="结合源码分析 String 类用法"></a>结合源码分析 String 类用法</h3><p>技术有限，目前仅对基础部分进行尝试解读</p>
<h4 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h4><p>String 类中的字符串是通过字符数组实现的，源码内通过语句 <code>private final char value[]</code> 将字符数组定义为一个不可更改的常量，不过这个不可更改是相对于数组的地址来说的，数组的内容仍然是可以改变的，但是 String 类并没有对外暴露 value 数组的赋值接口，所以说 String 类是不可变字符序列也是没毛病的</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>String 类的构造函数有好几种，现在分别进行分析</p>
<p>1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String() &#123;</span><br><span class="line">        this.value = &quot;&quot;.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个构造器不接受参数，对应的声明形式为 <code>String 变量名 = new String()</code> ，这个构造器将一个空字符串(<code>&quot;&quot;</code>) 的 value 数组地址赋给 String 类内部的成员变量 value，当这个 value 的值被确定以后外部将无法对其进行更改，虽然说外部可以进行两个 String 对象的相互赋值，但这本质上只是对实例对象地址的操作，对象内部的内容并没有变。</p>
<p>2.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public String(String original) &#123;</span><br><span class="line">        this.value = original.value;</span><br><span class="line">        this.hash = original.hash;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个构造器就很神奇，传入的参数竟然是另一个 String 类对象。实例化的代码是<code>String a = new String(&quot;abc&quot;)</code> 还可以这么写</p>
<p><code>String c = new String(new String(new String(new String(new String(new String(&quot;abc&quot;))))))</code> 不看源码都不知道原来还能这么玩。。。</p>
<p>看构造器的代码，它是将传入对象的 value 数组地址交给新生成的对象，也就是说通过该构造方法生成新对象的内容和原对象是相同的，但两个对象的内存地址是不同的，这种方法相当于将原字符串复制了一份</p>
<p>3.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public String(char value[], int offset, int count) &#123;</span><br><span class="line">        if (offset &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(offset);</span><br><span class="line">        &#125;</span><br><span class="line">        if (count &lt;= 0) &#123;</span><br><span class="line">            if (count &lt; 0) &#123;</span><br><span class="line">                throw new StringIndexOutOfBoundsException(count);</span><br><span class="line">            &#125;</span><br><span class="line">            if (offset &lt;= value.length) &#123;</span><br><span class="line">                this.value = &quot;&quot;.value;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // Note: offset or count might be near -1&gt;&gt;&gt;1.</span><br><span class="line">        if (offset &gt; value.length - count) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">        &#125;</span><br><span class="line">        this.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个构造器要求 3 个参数，其中一个是字符数组，另外两个都是整型数字，这个看看大致也能猜出是从字符数组中截取一段形成一个新的字符串。再来看看构造器的内容：</p>
<p>首先是几个界限判断，然后是一个数组按界限复制并赋值给新对象的 value 成员变量。结合起来就是将数组的[offset,offset+count) 内容复制为新字符串变量内容。需要注意的是，这里面的 offset 也就是起始复制位置是按数组中的位置来定的，比如说 test 这个字符串，其中的 t 就应该是第 0 位，而不是第 1 位。</p>
<p>后面几个看不太懂，以后再看</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法挑几个自己能看得懂的，平时也用得到的看看</p>
<h5 id="length-和-isEmpty"><a href="#length-和-isEmpty" class="headerlink" title="length 和 isEmpty"></a>length 和 isEmpty</h5><p>先来两个个简单粗暴地</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//返回字符串长度</span><br><span class="line">public int length() &#123;</span><br><span class="line">        return value.length;</span><br><span class="line">    &#125;</span><br><span class="line">//返回字符串是否为空</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">        return value.length == 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            <span class="keyword">int</span> n = value.length;</span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="keyword">char</span> v1[] = value;</span><br><span class="line">                <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>equals 是用来判断两个字符串是否相等的方法，这个方法里显示判断两个对象是否是同一个对象，之后判断与字符串进行比较的变量是否是 String 类或其子类的实例，不过由于 String 类是不可继承的，所以这就是用来判断是不是 String 类了，再下面就是正常的两个数组的比较了</p>
<h5 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith"></a>startsWith</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">char</span> ta[] = value;</span><br><span class="line">       <span class="keyword">int</span> to = toffset;</span><br><span class="line">       <span class="keyword">char</span> pa[] = prefix.value;</span><br><span class="line">       <span class="keyword">int</span> po = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> pc = prefix.value.length;</span><br><span class="line">       <span class="comment">// Note: toffset might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">       <span class="keyword">if</span> ((toffset &lt; <span class="number">0</span>) || (toffset &gt; value.length - pc)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (--pc &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (ta[to++] != pa[po++]) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是用来判断另一个字符串是否是当前字符串的子串。此方法将当前字符串以及待比较字符串的字符数组分别赋给 ta[] 和 pa[]，然后从 ta[toffset] 开始其后的字符与 pa[] 中的一致，那么就可以认为待比较字符串是原字符串的子串。startsOf  还有一个重载的方法没有 int 参数，这个方法是判断原字符串是否以指定字符串开头。</p>
<h5 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith"></a>endsWith</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startsWith(suffix, value.length - suffix.value.length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该方法在前一个方法的基础上建立的，主要用来判断待比较字符串与原字符串的尾部是否相同。</p>
<h5 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (oldChar != newChar) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = value.length;</span><br><span class="line">            <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span>[] val = value; <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">                <span class="keyword">if</span> (val[i] == oldChar) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                    buf[j] = val[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                    <span class="keyword">char</span> c = val[i];</span><br><span class="line">                    buf[i] = (c == oldChar) ? newChar : c;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>replace 的作用是将字符串内指定的字符替换为另一个指定的字符，他的时间复杂度为 n，看来是在设计之初就考虑过效率的问题。不过这个字符串的复制干吗要写成两个循环呢，明明一个循环就能搞定的事。感觉可能是为了减少判断，如果需要替换的字符串在相对较后的位置，这样就能减少很多比较操作，提高效率从点滴做起。。</p>
<h5 id="split-源码看不懂"><a href="#split-源码看不懂" class="headerlink" title="split(源码看不懂)"></a>split(源码看不懂)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public String[] split(String regex, int limit) &#123;</span><br><span class="line">        /* fastpath if the regex is a</span><br><span class="line">         (1)one-char String and this character is not one of the</span><br><span class="line">            RegEx&apos;s meta characters &quot;.$|()[&#123;^?*+\\&quot;, or</span><br><span class="line">         (2)two-char String and the first char is the backslash and</span><br><span class="line">            the second is not the ascii digit or ascii letter.</span><br><span class="line">         */</span><br><span class="line">        char ch = 0;</span><br><span class="line">        if (((regex.value.length == 1 &amp;&amp;</span><br><span class="line">             &quot;.$|()[&#123;^?*+\\&quot;.indexOf(ch = regex.charAt(0)) == -1) ||</span><br><span class="line">             (regex.length() == 2 &amp;&amp;</span><br><span class="line">              regex.charAt(0) == &apos;\\&apos; &amp;&amp;</span><br><span class="line">              (((ch = regex.charAt(1))-&apos;0&apos;)|(&apos;9&apos;-ch)) &lt; 0 &amp;&amp;</span><br><span class="line">              ((ch-&apos;a&apos;)|(&apos;z&apos;-ch)) &lt; 0 &amp;&amp;</span><br><span class="line">              ((ch-&apos;A&apos;)|(&apos;Z&apos;-ch)) &lt; 0)) &amp;&amp;</span><br><span class="line">            (ch &lt; Character.MIN_HIGH_SURROGATE ||</span><br><span class="line">             ch &gt; Character.MAX_LOW_SURROGATE))</span><br><span class="line">        &#123;</span><br><span class="line">            int off = 0;</span><br><span class="line">            int next = 0;</span><br><span class="line">            boolean limited = limit &gt; 0;</span><br><span class="line">            ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">            while ((next = indexOf(ch, off)) != -1) &#123;</span><br><span class="line">                if (!limited || list.size() &lt; limit - 1) &#123;</span><br><span class="line">                    list.add(substring(off, next));</span><br><span class="line">                    off = next + 1;</span><br><span class="line">                &#125; else &#123;    // last one</span><br><span class="line">                    //assert (list.size() == limit - 1);</span><br><span class="line">                    list.add(substring(off, value.length));</span><br><span class="line">                    off = value.length;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // If no match was found, return this</span><br><span class="line">            if (off == 0)</span><br><span class="line">                return new String[]&#123;this&#125;;</span><br><span class="line"></span><br><span class="line">            // Add remaining segment</span><br><span class="line">            if (!limited || list.size() &lt; limit)</span><br><span class="line">                list.add(substring(off, value.length));</span><br><span class="line"></span><br><span class="line">            // Construct result</span><br><span class="line">            int resultSize = list.size();</span><br><span class="line">            if (limit == 0) &#123;</span><br><span class="line">                while (resultSize &gt; 0 &amp;&amp; list.get(resultSize - 1).length() == 0) &#123;</span><br><span class="line">                    resultSize--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] result = new String[resultSize];</span><br><span class="line">            return list.subList(0, resultSize).toArray(result);</span><br><span class="line">        &#125;</span><br><span class="line">        return Pattern.compile(regex).split(this, limit);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>源码看不懂啥意思，不过这个方法用处挺广的，在这里记录一下。此方法可以用来将字符串按照指定字符切割成多个字符子串。用法是 <code>String[] 变量名 = 字符串.split(作为分割线的字符串)</code> 举个例子 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;abcd&quot;;</span><br><span class="line">String[] f =a.split(&quot;bc&quot;);</span><br></pre></td></tr></table></figure>
<p>这时 f[0] == “a”; f[1] == “d”</p>
<h5 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h5><p>这个方法就不放源码了，因为这个方法有一系列重载的方法，其功能都是将相关的对象转换为字符串。</p>
<h5 id="equalsIgnoreCase-anotherString"><a href="#equalsIgnoreCase-anotherString" class="headerlink" title="equalsIgnoreCase(anotherString)"></a>equalsIgnoreCase(anotherString)</h5><p>这个方法用来是 equals 的加强版，忽略大小写进行比较。比如说<code>boolean a = &quot;Abc&quot;.equalsIgnoreCase(&quot;abc&quot;)</code> 返回值将是 true</p>
<h5 id="indexOf-和-lastIndexOf"><a href="#indexOf-和-lastIndexOf" class="headerlink" title="indexOf 和 lastIndexOf"></a>indexOf 和 lastIndexOf</h5><p>此方法用来返回指定字符在字符串中的位置，不同的是 indexOf 是从左往右找，lastIndexOf 是从右往左找，相同的是二者都只会返回第一个符合条件字符的位置。</p>
<p>示例 <code>int a = &quot;abcde&quot;.indexOf(&quot;b&quot;)</code> 运行后 a 的值是 1 </p>
<h5 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h5><p>substring 的作用是在原字符串上截取一个子字符串。该方法有两个重载的方法，分别接受一个和两个 int 类型的参数，接受 1 个参数的是从该参数位置截取到字符串尾部，理所当然，接受两个参数的就是截取两个参数之间部分的字符串。用法示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;abcde&quot;.substring(1));</span><br><span class="line">输出 bcde</span><br><span class="line">System.out.println(&quot;abcde&quot;.substring(0,2));</span><br><span class="line">输出 ab</span><br></pre></td></tr></table></figure>
<h5 id="toLowerCase-和-toUpperCase"><a href="#toLowerCase-和-toUpperCase" class="headerlink" title="toLowerCase 和 toUpperCase"></a>toLowerCase 和 toUpperCase</h5><p>这两个方法分别用来将字符串转换成大写和小写，用法示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;Abc&quot;.toLowerCase());</span><br><span class="line">输出    abc</span><br><span class="line">System.out.println(&quot;Abc&quot;.toUpperCase());</span><br><span class="line">输出    ABC</span><br></pre></td></tr></table></figure>
<h4 id="一个小知识点"><a href="#一个小知识点" class="headerlink" title="一个小知识点"></a>一个小知识点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String gh = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">    gh = gh+i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String gh = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line"> gh = gh+i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个语句一共创建了 1001 个对象，第二个对象一共创建了 1002 个对象。这种写法非常浪费空间</p>
<h4 id="StringBuilder-和-StringBuffer"><a href="#StringBuilder-和-StringBuffer" class="headerlink" title="StringBuilder 和 StringBuffer"></a>StringBuilder 和 StringBuffer</h4><p>StringBuffer是线程安全的，但效率低；StringBuilder 是线程不安全的，但效率高</p>
<p>看一下 StringBuffer 的用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStringBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuffer(<span class="string">"123"</span>);</span><br><span class="line">        System.out.println(sb.append(<span class="string">"45678912321456789"</span>));</span><br><span class="line">        System.out.println(sb.capacity());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>StringBuiler 是一个可变字符序列，其构造器可接受整数和字符串两种类型的数据，不过字符串传进去也会被转化为字符串长度的整型变量，很鸡贼！构造器接收整型参数后将会创建一个整型变量 +16 长度的字符串数组然后再将字符串存进去，同时可使用 append 方法向 StringBuilder 字符串数组中添加字符串，如果数组长度不够其内部会自动延长数组长度，延长规则是创建一个新数组长度在原有基础上 * 2 + 2 ，然后将原有数组内容复制到新数组中，之后重新比较，如果不行就再次延长。</p>
<p>同时对于上面的 for 循环拼接字符串也有了一个更好的处理方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder gh = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">     gh.append(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写新建的对象数量会少很多</p>
<p>再说一个关于 append 的知识点，查看 append 方法的源码可以发现此方法返回的是一个 this 对象，也就是对象本身，所以在使用 append 方法后仍然可以继续使用其他方法。比如说，我们可以一直 append 。</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>爱笑的代码狗</p>
<p>容器的本质是列表，但相较于列表，容器有一个非常大的优点就是他能自适应的更改自身的程度，其更改长度的原理是在原来长度的基础上新建一个更长的数组来替换原先的数组。除了这点，其余操作和数组并没有态度的区别（个人感觉）</p>
<h4 id="容器中的一些方法"><a href="#容器中的一些方法" class="headerlink" title="容器中的一些方法"></a>容器中的一些方法</h4><h5 id="数组复制"><a href="#数组复制" class="headerlink" title="数组复制"></a>数组复制</h5><p><code>System.arraycopy(原数组,原数组复制起点,新数组,新数组赋值起点,复制长度)</code> 这真的是一个很有用的语句，不仅是在数组复制上，在数组的插入时的元素后移上（原数组复制）也是十分有用的</p>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>虽说  java 是面向对象的语言，但是 java 并不是完全面向对象的，他的 8 个基本数据类型并不是对象，为此，Java 中引入了包装类的概念来将基本数据类型装化为类。8 个基本数据类型分别对应 8 个包装类，除了 int 和 char，其他几个基本数据类型的包装类就是将首字母大写，而 int 的包装类是 Integer ，char 的是 Character。</p>
<p>使用 int 数据类型包装类的语法为：<code>Integer a = new Integer(123);</code> 其他数据类型和这个都差不多。如果要将类重新转化为 基本数据类型则需要使用 int b = a.intValue()</p>
<h4 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h4><p>上述的相互转换还有一种更简单的写法，这也就是现在要说的自动拆装箱。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">int</span> b = a;</span><br><span class="line"><span class="keyword">int</span> c = a + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>上述几个语句都是正确的，为了方便开发者使用包装类，java 团队对编译器进行了处理，使包装类能够根据需要自行处理格式，也就是加几个判断，当遇到上述表达式时自动在语句中加上缺少的关键字。</p>
<p>再来看几个语句</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        Integer b = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(a==b);</span><br><span class="line">        System.out.println(a.equals(b));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行以上代码时，第一个输出语句将会打印 false ，第二个将会打印 true。可如果将上面的数字由 1000 改为 -128 至 127 之间的数字，两个都将会返回 true，这是因为当数字在这个范围内时 java 在运算和处理时会将包装类当成基本数据类型处理，以提高效率。</p>
<h3 id="IO-流的基本操作"><a href="#IO-流的基本操作" class="headerlink" title="IO 流的基本操作"></a>IO 流的基本操作</h3><p>IO 流的操作分为读和写两种操作，首先介绍写操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        String fileName = <span class="string">"C:"</span>+File.separator+<span class="string">"Users"</span>+File.separator+<span class="string">"C"</span>+File.separator+<span class="string">"desktop"</span>+File.separator+<span class="string">"新建文本文档.txt"</span>;</span><br><span class="line">        <span class="comment">//建立连接，后面的 true表示追加模式</span></span><br><span class="line"></span><br><span class="line">        OutputStream output = <span class="keyword">new</span> FileOutputStream(filEName,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        String str = <span class="string">"\r\n123安徽"</span>;</span><br><span class="line">        <span class="comment">//将字符串转为字节数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] b = str.getBytes();</span><br><span class="line">        <span class="comment">//将字节数据写入文件</span></span><br><span class="line"></span><br><span class="line">        output.write(b);</span><br><span class="line">        output.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接下来再说读操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        String fileName = <span class="string">"C:"</span>+File.separator+<span class="string">"Users"</span>+File.separator+<span class="string">"C"</span>+File.separator+<span class="string">"desktop"</span>+File.separator+<span class="string">"新建文本文档.txt"</span>;</span><br><span class="line">        InputStream input = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">        <span class="comment">//数组 b 表示每次读取的数据大小，缓冲数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">//input.read(b) 语句将会在流中尽量取数组长度的字节缓冲到数组 b 中，如果数组不够长则会分多次进行读取，每次返回数组 b 中的字节个数，如果返回 -1 则说明文件已经结束。read还有一种无参方法，每次读取 1 字节数据，不过这种读取方法是针对英文字符用的，汉字都是两个字符组成的，所以在读取汉字文件时不能使用小于 2 且不能被 2 整除长度的缓冲数组，否则会乱码。</span></span><br><span class="line">        <span class="comment">//但是如果文件是中英文混合的话除非缓冲数组设置特别大能够一次读取完文件，不然的话我感觉这肯定会出错的啊，不知道这种问题咋解决的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(-<span class="number">1</span>!=input.read(b))&#123;</span><br><span class="line">            String str = <span class="keyword">new</span> String(b);</span><br><span class="line">            System.out.print(str);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(input.read());</span><br><span class="line">        input.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于读取文件提速可以使用 BufferedInputStream 类，这个类设置有一个缓冲区，可以将文件缓冲一部分到内存中以供 cpu 快速调用，等到 cpu 读取完成后再进行下一次缓存。我咋感觉这个方法和上面的读取方式没多大区别呢。。。都是存到内存缓冲，不知道这个方法为啥更快。为此特别验证了一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyAndReplace</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		FileInputStream f = <span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\C\\Desktop\\杂货\\1.zip"</span>);</span><br><span class="line"></span><br><span class="line">		FileInputStream f1 = <span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\C\\Desktop\\杂货\\1.zip"</span>);</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

	
	<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-----------本文结束<i class="fa  fa-paper-plane-o"></i>感谢您的阅读-----------</div>
    
</div>
  
</div>


    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    or
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://c-or.github.io/2019/java-learning.html" title="java 学习全程记录">https://c-or.github.io/2019/java-learning.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/verification-code-recognition.html" rel="next" title="各种验证码的处理">
                <i class="fa fa-chevron-left"></i> 各种验证码的处理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/Python-爬虫踩坑集锦.html" rel="prev" title="Python 爬虫踩坑集锦">
                Python 爬虫踩坑集锦 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="or">
            
              <p class="site-author-name" itemprop="name">or</p>
              <p class="site-description motion-element" itemprop="description">未来的全栈工程师</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          
<div id="days"></div>
<script>
function show_date_time(){
window.setTimeout("show_date_time()", 1000);
BirthDay=new Date("01/18/2019 20:24:13");
today=new Date();
timeold=(today.getTime()-BirthDay.getTime());
sectimeold=timeold/1000
secondsold=Math.floor(sectimeold);
msPerDay=24*60*60*1000
e_daysold=timeold/msPerDay
daysold=Math.floor(e_daysold);
e_hrsold=(e_daysold-daysold)*24;
hrsold=setzero(Math.floor(e_hrsold));
e_minsold=(e_hrsold-hrsold)*60;
minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
seconds=setzero(Math.floor((e_minsold-minsold)*60));
document.getElementById('days').innerHTML="已经在各种折腾中运行了 "+daysold+" 天 "+hrsold+" 小时 "+minsold+" 分 "+seconds+" 秒";
}
function setzero(i){
if (i<10)
{i="0" + i};
return i;
}
show_date_time();
</script>
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#java-中关于类的操作"><span class="nav-number">1.</span> <span class="nav-text">java 中关于类的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类的写法"><span class="nav-number">1.1.</span> <span class="nav-text">类的写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-中类的实例化"><span class="nav-number">1.2.</span> <span class="nav-text">java 中类的实例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-中构造方法及其作用"><span class="nav-number">1.3.</span> <span class="nav-text">java 中构造方法及其作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this-的使用场景"><span class="nav-number">1.4.</span> <span class="nav-text">this 的使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static-用法"><span class="nav-number">1.5.</span> <span class="nav-text">static 用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包的导入"><span class="nav-number">1.6.</span> <span class="nav-text">包的导入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#静态导入"><span class="nav-number">1.6.1.</span> <span class="nav-text">静态导入</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾回收算法与机制"><span class="nav-number">2.</span> <span class="nav-text">垃圾回收算法与机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收算法"><span class="nav-number">2.1.</span> <span class="nav-text">垃圾回收算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收机制"><span class="nav-number">2.2.</span> <span class="nav-text">垃圾回收机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">3.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#继承方法的重写"><span class="nav-number">3.1.</span> <span class="nav-text">继承方法的重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super-的用法"><span class="nav-number">3.2.</span> <span class="nav-text">super 的用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类的向上向下转型"><span class="nav-number">3.2.1.</span> <span class="nav-text">类的向上向下转型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#封装"><span class="nav-number">3.3.</span> <span class="nav-text">封装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#访问控制符"><span class="nav-number">3.3.1.</span> <span class="nav-text">访问控制符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多态"><span class="nav-number">3.4.</span> <span class="nav-text">多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final关键字"><span class="nav-number">3.5.</span> <span class="nav-text">final关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#foreach-循环"><span class="nav-number">3.6.</span> <span class="nav-text">foreach 循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类"><span class="nav-number">3.7.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口"><span class="nav-number">3.8.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回调函数"><span class="nav-number">3.9.</span> <span class="nav-text">回调函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类"><span class="nav-number">3.10.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内部类的作用"><span class="nav-number">3.10.1.</span> <span class="nav-text">内部类的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部类的使用场合"><span class="nav-number">3.10.2.</span> <span class="nav-text">内部类的使用场合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非静态内部类"><span class="nav-number">3.10.3.</span> <span class="nav-text">非静态内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态内部类"><span class="nav-number">3.10.4.</span> <span class="nav-text">静态内部类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结合源码分析-String-类用法"><span class="nav-number">3.11.</span> <span class="nav-text">结合源码分析 String 类用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#变量的定义"><span class="nav-number">3.11.1.</span> <span class="nav-text">变量的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数"><span class="nav-number">3.11.2.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法"><span class="nav-number">3.11.3.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#length-和-isEmpty"><span class="nav-number">3.11.3.1.</span> <span class="nav-text">length 和 isEmpty</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#equals"><span class="nav-number">3.11.3.2.</span> <span class="nav-text">equals</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#startsWith"><span class="nav-number">3.11.3.3.</span> <span class="nav-text">startsWith</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#endsWith"><span class="nav-number">3.11.3.4.</span> <span class="nav-text">endsWith</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#replace"><span class="nav-number">3.11.3.5.</span> <span class="nav-text">replace</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#split-源码看不懂"><span class="nav-number">3.11.3.6.</span> <span class="nav-text">split(源码看不懂)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#valueOf-NaN"><span class="nav-number">3.11.3.7.</span> <span class="nav-text">valueOf</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#equalsIgnoreCase-anotherString"><span class="nav-number">3.11.3.8.</span> <span class="nav-text">equalsIgnoreCase(anotherString)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#indexOf-和-lastIndexOf"><span class="nav-number">3.11.3.9.</span> <span class="nav-text">indexOf 和 lastIndexOf</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#substring"><span class="nav-number">3.11.3.10.</span> <span class="nav-text">substring</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#toLowerCase-和-toUpperCase"><span class="nav-number">3.11.3.11.</span> <span class="nav-text">toLowerCase 和 toUpperCase</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一个小知识点"><span class="nav-number">3.11.4.</span> <span class="nav-text">一个小知识点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StringBuilder-和-StringBuffer"><span class="nav-number">3.11.5.</span> <span class="nav-text">StringBuilder 和 StringBuffer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器"><span class="nav-number">3.12.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#容器中的一些方法"><span class="nav-number">3.12.1.</span> <span class="nav-text">容器中的一些方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#数组复制"><span class="nav-number">3.12.1.1.</span> <span class="nav-text">数组复制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包装类"><span class="nav-number">3.13.</span> <span class="nav-text">包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自动拆装箱"><span class="nav-number">3.13.1.</span> <span class="nav-text">自动拆装箱</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO-流的基本操作"><span class="nav-number">3.14.</span> <span class="nav-text">IO 流的基本操作</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-space-shuttle"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">or</span>

  
</div>










<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 历史访客数：
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量：
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  











<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'mekozA0UPKdv6jsVUJorM0oi-gzGzoHsz',
    appKey: '9cogxMEK1jdfYhWfP3EC2Ck2',
    placeholder: '欢迎吐槽',
    avatar: '/uploads/avatar.png',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true
  });
</script>


  





  

  

  

  
  

  

  

  

</body>
</html>
